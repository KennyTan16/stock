"""Cross Check Analysis

Compares actual backtest alert outputs against expectation records generated by
expectation_builder.py. Produces a summary with:
  - Coverage (fraction of expected Stage1 / Stage2 events captured)
  - Miss list (expected events not found in actual alerts)
  - False positives (alerts without matching expectation at same minute/stage)
  - Latency (minutes between expected and actual for Stage1->Stage2 sequences)

Inputs:
  results/alert_expectations.json
  results/backtest_results_flatfiles_*.json  (latest by timestamp)

Output:
  results/cross_check_summary.json

Matching Logic:
  - Key: (symbol, date, stage_expected)
  - For Stage1/Stage2 we compare minute timestamps (ISO truncated to minute)
  - Allow +/-1 minute tolerance for Stage2 confirmation (grace window) to account for bar boundary drift.

"""
from __future__ import annotations
import json, os, re
from pathlib import Path
from datetime import datetime, timedelta
from collections import defaultdict

PROJECT_ROOT = Path(__file__).resolve().parent.parent
RESULTS_DIR = PROJECT_ROOT / 'results'
EXPECT_PATH = RESULTS_DIR / 'alert_expectations.json'
SUMMARY_PATH = RESULTS_DIR / 'cross_check_summary.json'

# Helpers

def load_expectations():
    if not EXPECT_PATH.exists():
        raise FileNotFoundError(f"Expectation file not found: {EXPECT_PATH}")
    data = json.loads(EXPECT_PATH.read_text())
    return data['records']


def find_latest_backtest():
    candidates = sorted(RESULTS_DIR.glob('backtest_results_flatfiles_*.json'))
    if not candidates:
        raise FileNotFoundError("No backtest result files found.")
    return candidates[-1]


def load_backtest(path: Path):
    data = json.loads(path.read_text())
    return data['alerts']


def iso_minute(ts_iso: str) -> str:
    # Normalize to minute precision: YYYY-MM-DDTHH:MM
    return ts_iso[:16]


def build_index_expect(records):
    idx = defaultdict(list)
    for r in records:
        # Normalize to minute precision & store for tolerant matching
        minute_key = iso_minute(r['minute_ts'])
        key = (r['symbol'], r['date'], r['stage_expected'])
        r['_minute_key'] = minute_key
        idx[key].append(r)
    return idx


def build_index_actual(alerts):
    idx = defaultdict(list)
    for a in alerts:
        ts = a['timestamp']
        date = ts[:10]
        stage = a.get('stage')
        minute_key = iso_minute(ts)
        a['_minute_key'] = minute_key
        key = (a['symbol'], date, stage)
        idx[key].append(a)
    return idx


def cross_check(expect_records, actual_alerts):
    """Enhanced cross check with tolerant matching and promotion semantics.

    Tolerance Rules:
      - Stage1: treat expected minute as captured if actual Stage1 alert occurs same minute OR +1 minute.
      - Stage2: treat expected minute as captured if actual Stage2 occurs same minute OR +/-1 minute.
      - Promotion: expected Stage0 treated as contributing to Stage1 coverage if an actual Stage1 occurs within 0-2 minutes after the Stage0 minute (and that Stage0 minute wasn't already an expected Stage1 capture).

    Coverage fields:
      stage1.captured_exact: same-minute matches to expected Stage1.
      stage1.captured_tolerant: +1 minute tolerant matches.
      stage1.promoted_from_stage0: promotions from Stage0 watches.
      stage1.unique_captured: union of above (deduplicated by minute).
      stage2.captured_exact: same-minute matches.
      stage2.captured_tolerant: +/-1 minute matches.
      stage2.unique_captured: union.
    """
    exp_index = build_index_expect(expect_records)
    act_index = build_index_actual(actual_alerts)

    coverage = {
        'stage0': {'expected': 0, 'captured': 0},  # stage0 actual alerts typically not emitted
        'stage1': {
            'expected': 0,
            'captured_exact': 0,
            'captured_tolerant': 0,
            'promoted_from_stage0': 0,
            'unique_captured': 0,
        },
        'stage2': {
            'expected': 0,
            'captured_exact': 0,
            'captured_tolerant': 0,
            'unique_captured': 0,
        },
    }

    missed = []
    false_positives = []
    promotion_samples = []
    latency_samples = []  # minutes diff between expected Stage1 and actual Stage2 earliest pair

    def plus_minutes(minute_str: str, delta: int) -> str:
        dt = datetime.fromisoformat(minute_str + ':00') if len(minute_str) == 16 else datetime.fromisoformat(minute_str)
        return (dt + timedelta(minutes=delta)).isoformat()[:16]

    # Build symbol/date wise caches for promotion logic
    symbol_date_sets = defaultdict(lambda: {'exp_stage0': set(), 'exp_stage1': set(), 'act_stage1': set(), 'act_stage2': set()})
    for r in expect_records:
        sd = symbol_date_sets[(r['symbol'], r['date'])]
        if r['stage_expected'] == 0:
            sd['exp_stage0'].add(r['_minute_key'])
        elif r['stage_expected'] == 1:
            sd['exp_stage1'].add(r['_minute_key'])
        elif r['stage_expected'] == 2:
            sd['act_stage2']  # placeholder
    for a in actual_alerts:
        sd = symbol_date_sets[(a['symbol'], a['timestamp'][:10])]
        if a.get('stage') == 1:
            sd['act_stage1'].add(a['_minute_key'])
        elif a.get('stage') == 2:
            sd['act_stage2'].add(a['_minute_key'])

    # Coverage & miss detection (Stage0/1/2 expectations -> actuals)
    for key, exp_list in exp_index.items():
        symbol, date, stage = key
        stage_label = f'stage{stage}'
        if stage_label in coverage:
            coverage[stage_label]['expected'] += len(exp_list)
        actual_list = act_index.get(key, [])
        exp_minutes = [e['_minute_key'] for e in exp_list]
        act_minutes = [a['_minute_key'] for a in actual_list]
        act_minutes_set = set(act_minutes)

        if stage == 1:
            captured_exact = set()
            captured_tolerant = set()
            for m in exp_minutes:
                if m in act_minutes_set:
                    captured_exact.add(m)
                else:
                    m_plus = plus_minutes(m, 1)
                    if m_plus in act_minutes_set:
                        captured_tolerant.add(m)
            coverage['stage1']['captured_exact'] += len(captured_exact)
            coverage['stage1']['captured_tolerant'] += len(captured_tolerant)
            # Misses (those not captured at all)
            for m in exp_minutes:
                if m not in captured_exact and m not in captured_tolerant:
                    missed.append({'symbol': symbol, 'date': date, 'stage': stage, 'minute_ts': [e['minute_ts'] for e in exp_list if e['_minute_key']==m][0], 'confirmation_type': None, 'reason': 'stage1_not_captured_tolerant'})
        elif stage == 2:
            captured_exact = set()
            captured_tolerant = set()
            for m in exp_minutes:
                if m in act_minutes_set:
                    captured_exact.add(m)
                else:
                    # +/-1 minute tolerance
                    m_minus = plus_minutes(m, -1)
                    m_plus = plus_minutes(m, 1)
                    if m_minus in act_minutes_set or m_plus in act_minutes_set:
                        captured_tolerant.add(m)
            coverage['stage2']['captured_exact'] += len(captured_exact)
            coverage['stage2']['captured_tolerant'] += len(captured_tolerant)
            for m in exp_minutes:
                if m not in captured_exact and m not in captured_tolerant:
                    missed.append({'symbol': symbol, 'date': date, 'stage': stage, 'minute_ts': [e['minute_ts'] for e in exp_list if e['_minute_key']==m][0], 'confirmation_type': None, 'reason': 'stage2_not_captured_tolerant'})
        else:
            # Stage0 expectations currently not directly matched (no actual stage0 alerts)
            if not actual_list:
                for exp in exp_list:
                    missed.append({'symbol': symbol, 'date': date, 'stage': stage, 'minute_ts': exp['minute_ts'], 'confirmation_type': exp.get('confirmation_type'), 'reason': 'stage_absent'})

    # Promotion logic: expected Stage0 -> actual Stage1 within 0-2 minutes window
    for (symbol, date), sets in symbol_date_sets.items():
        window_captures = set()
        for m0 in sets['exp_stage0']:
            dt0 = datetime.fromisoformat(m0 + ':00') if len(m0) == 16 else datetime.fromisoformat(m0)
            for offset in range(0, 3):
                candidate = (dt0 + timedelta(minutes=offset)).isoformat()[:16]
                if candidate in sets['act_stage1']:
                    # Avoid counting promotions that correspond to an expected stage1 already captured
                    if candidate not in sets['exp_stage1']:
                        window_captures.add(m0)
                        promotion_samples.append({'symbol': symbol, 'date': date, 'stage0_minute': m0, 'stage1_minute': candidate, 'offset_min': offset})
                    break
        coverage['stage1']['promoted_from_stage0'] += len(window_captures)

    # Compute unique captured counts
    coverage['stage1']['unique_captured'] = coverage['stage1']['captured_exact'] + coverage['stage1']['captured_tolerant'] + coverage['stage1']['promoted_from_stage0']
    coverage['stage2']['unique_captured'] = coverage['stage2']['captured_exact'] + coverage['stage2']['captured_tolerant']

    # False positives: actual alerts without expectation (strict same-minute for their own stage)
    for key, act_list in act_index.items():
        symbol, date, stage = key
        exp_list = exp_index.get(key, [])
        exp_minutes = {e['_minute_key'] for e in exp_list}
        for a in act_list:
            if a['_minute_key'] not in exp_minutes:
                false_positives.append({'symbol': symbol, 'date': date, 'stage': stage, 'timestamp': a['timestamp'], 'pct_change': a.get('pct_change'), 'quality_score': a.get('quality_score')})

    # Latency: earliest expected Stage1 vs earliest actual Stage2 per symbol/date
    for symbol_date in {(r['symbol'], r['date']) for r in expect_records}:
        symbol, date = symbol_date
        exp_stage1 = exp_index.get((symbol, date, 1), [])
        act_stage2 = act_index.get((symbol, date, 2), [])
        if exp_stage1 and act_stage2:
            try:
                exp_ts = min(datetime.fromisoformat(r['minute_ts']) for r in exp_stage1)
                act_ts = min(datetime.fromisoformat(a['timestamp']) for a in act_stage2)
                diff_min = (act_ts - exp_ts).total_seconds() / 60.0
                latency_samples.append(diff_min)
            except Exception:
                pass

    latency_summary = {
        'count': len(latency_samples),
        'avg_minutes': (sum(latency_samples) / len(latency_samples)) if latency_samples else None,
        'min_minutes': min(latency_samples) if latency_samples else None,
        'max_minutes': max(latency_samples) if latency_samples else None,
    }

    summary = {
        'generated_at': datetime.utcnow().isoformat() + 'Z',
        'coverage': coverage,
        'missed_count': len(missed),
        'false_positive_count': len(false_positives),
        'latency': latency_summary,
        'missed_samples': missed[:200],
        'false_positive_samples': false_positives[:200],
        'promotion_samples': promotion_samples[:200],
    }
    return summary


def main():
    expect_records = load_expectations()
    backtest_path = find_latest_backtest()
    actual_alerts = load_backtest(backtest_path)
    print(f"[INFO] Using backtest file: {backtest_path.name} ({len(actual_alerts)} alerts)")
    summary = cross_check(expect_records, actual_alerts)
    SUMMARY_PATH.write_text(json.dumps(summary, indent=2))
    print(f"[OK] Cross-check summary written -> {SUMMARY_PATH}")
    print(json.dumps(summary['coverage'], indent=2))
    print('[INFO] Missed:', summary['missed_count'], '| False positives:', summary['false_positive_count'])
    if summary['latency']['avg_minutes'] is not None:
        print('[INFO] Avg Stage1->Stage2 latency (min):', round(summary['latency']['avg_minutes'], 2))

if __name__ == '__main__':
    main()
